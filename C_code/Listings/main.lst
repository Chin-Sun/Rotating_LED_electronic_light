C51 COMPILER V9.56.0.0   MAIN                                                              07/19/2019 10:58:36 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\各软件\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main.
                    -lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include<reg51.h>
   2          #define uchar unsigned char
   3          #define uint unsigned int
   4          const uchar code clock[12][16]={
   5          
   6          0xFF,0xFF,0x1F,0xF0,0xEF,0xEF,0xF7,0xDF,0xF7,0xDF,0xEF,0xEF,0x1F,0xF0,0xFF,0xFF,/*0*/
   7          
   8          0xFF,0xFF,0xFF,0xFF,0xEF,0xDF,0xEF,0xDF,0x07,0xC0,0xFF,0xDF,0xFF,0xDF,0xFF,0xFF,/*1*/
   9          
  10          0xFF,0xFF,0x8F,0xCF,0xF7,0xD7,0xF7,0xDB,0xF7,0xDD,0xF7,0xDE,0x0F,0xCF,0xFF,0xFF,/*2*/
  11          
  12          0xFF,0xFF,0xCF,0xE7,0xF7,0xDF,0xF7,0xDE,0xF7,0xDE,0x77,0xDD,0x8F,0xE3,0xFF,0xFF,/*3*/
  13          
  14          0xFF,0xFF,0xFF,0xF9,0x7F,0xFA,0xBF,0xDB,0xCF,0xDB,0x07,0xC0,0xFF,0xDB,0xFF,0xDB,/*4*/
  15          
  16          0xFF,0xFF,0x07,0xE6,0x77,0xDF,0x77,0xDF,0x77,0xDF,0xF7,0xEE,0xF7,0xF1,0xFF,0xFF,/*5*/
  17          
  18          0xFF,0xFF,0x1F,0xF0,0xEF,0xEE,0x77,0xDF,0x77,0xDF,0x6F,0xDF,0xFF,0xE0,0xFF,0xFF,/*6*/
  19          
  20          0xFF,0xFF,0xE7,0xFF,0xF7,0xFF,0xF7,0xC1,0x77,0xFE,0x97,0xFF,0xE7,0xFF,0xFF,0xFF,/*7*/
  21          
  22          0xFF,0xFF,0x8F,0xE3,0x77,0xDD,0xF7,0xDE,0xF7,0xDE,0x77,0xDD,0x8F,0xE3,0xFF,0xFF,/*8*/
  23          
  24          0xFF,0xFF,0x0F,0xFE,0xF7,0xED,0xF7,0xDD,0xF7,0xDD,0xEF,0xEE,0x1F,0xF0,0xFF,0xFF,/*9*/
  25          
  26          0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0xCF,0x3F,0xCF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,/*:*/
  27          
  28          0xFF,0xFF,0xFF,0xFE,0xFF,0xFE,0xFF,0xFE,0xFF,0xFE,0xFF,0xFE,0xFF,0xFE,0xFF,0xFF,/*-*/
  29          };
  30          unsigned int code text[] = {
  31          
  32          
  33          0xFF,0xDF,0xDF,0x9F,0xDF,0xDF,0xDF,0xEF,0xDF,0xEF,0x00,0x00,0xFF,0xFF,0xFF,0xFF,
  34          0xFF,0xFF,0x00,0xC0,0xBF,0xBF,0xDF,0xBF,0xEF,0xBF,0xF7,0xBF,0xFF,0x87,0xFF,0xFF,/*北*/
  35          
  36          0xFB,0xFF,0xFB,0xBF,0xFB,0xDF,0x1B,0xE4,0xDB,0xFD,0xDB,0xBD,0xDA,0x7D,0xD9,0x81,
  37          0xDB,0xFD,0xDB,0xFD,0xDB,0xFD,0x1B,0xF4,0xFB,0xEF,0xFB,0x9F,0xFB,0xFF,0xFF,0xFF,/*京*/
  38          
  39          0xEF,0xFB,0xEF,0xFC,0x2F,0xFF,0x00,0x00,0x6F,0xFF,0xEF,0xEE,0xFF,0xF7,0xEF,0xFB,
  40          0xEF,0xFC,0x2F,0xFF,0x00,0x00,0x2F,0xFF,0xEF,0xFC,0xEF,0xFB,0xEF,0xF7,0xFF,0xFF,/*林*/
  41          
  42          0xFF,0xBF,0xEF,0xBF,0x9F,0xBF,0x7F,0xBC,0xFF,0xBF,0x00,0x80,0xFF,0xBF,0xFF,0xBF,
  43          0xFF,0xBF,0x00,0x80,0xFF,0xBD,0xFF,0xBE,0x3F,0xBF,0xCF,0xBF,0xFF,0xBF,0xFF,0xFF,/*业*/
  44          
  45          0xDF,0x7F,0xDF,0x7F,0xDF,0xBF,0xDF,0xDF,0xDF,0xEF,0xDF,0xF3,0xDF,0xFC,0x00,0xFF,
  46          0xDF,0xFC,0xDF,0xF3,0xDF,0xEF,0xDF,0xDF,0xDF,0xBF,0xDF,0x7F,0xDF,0x7F,0xFF,0xFF,/*大*/
  47          
  48          0xBF,0xFB,0xCF,0xFB,0xEE,0xFB,0x69,0xFB,0x6F,0xFB,0x6F,0xBB,0x6E,0x7B,0x69,0x81,
  49          0x6F,0xF9,0x6F,0xFA,0x67,0xFB,0xEB,0xFB,0xEC,0xFB,0xAF,0xFB,0xCF,0xFB,0xFF,0xFF,/*学*/
  50          };
  51          
  52          unsigned int change(uint a)//读取字模
  53          {
  54   1        uint b=0x00,j,c;
C51 COMPILER V9.56.0.0   MAIN                                                              07/19/2019 10:58:36 PAGE 2   

  55   1        for(j=0;j<8;j++)
  56   1        {
  57   2          c=a&0x01;
  58   2          a=a>>1;
  59   2          b=b+c;
  60   2          if(j!=7)
  61   2          {
  62   3            b=b<<1;
  63   3          }
  64   2        }
  65   1        return b;
  66   1      }
  67          
  68          uchar starts_time[7]={0x30,0x59,0x14,0x19,0x07,0x03,0x19};   //初始化后设置 秒 分 时 日 月 星期 年//
  69          uchar Sec;
  70          uchar Cent;
  71          uchar Hour;
  72          uchar Year;
  73          uchar Day;
  74          uchar Week;
  75          uchar Month;
  76          
  77          sbit CLK =P3^5;       //DS1302引脚连接
  78          sbit IO =P3^6;
  79          sbit RST=P3^7;
  80          
  81          sbit ACC0=ACC^0;           //1bit数据存储位
  82          sbit ACC7=ACC^7;
  83          /******************************************************************/
  84          
  85          //根据选择调整相应项目
  86          //********DS1302读写程序***************//
  87          /******************************************************************** 
  88          函 数 名：RTInputByte()
  89          功    能：实时时钟写入一字节
  90          说    明：往DS1302写入1Byte数据 (内部函数)
  91          入口参数：d 写入的数据 
  92          返 回 值：无  
  93          ***********************************************************************/
  94          void RTInputByte(uchar d) 
  95          { 
  96   1          uchar h;
  97   1          ACC = d;
  98   1          for(h=8; h>0; h--)
  99   1          {
 100   2              IO = ACC0;           /*相当于汇编中的 RRC */
 101   2              CLK = 1;
 102   2              CLK = 0;
 103   2              ACC = ACC >> 1; 
 104   2          } 
 105   1      }
 106          /******************************************************************** 
 107          函 数 名：RTOutputByte()
 108          功    能：实时时钟读取一字节
 109          说    明：从DS1302读取1Byte数据 (内部函数)
 110          入口参数：无  
 111          返 回 值：ACC
 112          设    计：zhaojunjie           日    期：2002-03-19
 113          修    改：                     日    期： 
 114          ***********************************************************************/
 115          uchar RTOutputByte(void) 
 116          { 
C51 COMPILER V9.56.0.0   MAIN                                                              07/19/2019 10:58:36 PAGE 3   

 117   1          uchar h;
 118   1          for(h=8; h>0; h--)
 119   1          {
 120   2              ACC = ACC >>1;         /*相当于汇编中的 RRC */
 121   2              ACC7 = IO;
 122   2              CLK = 0;
 123   2              CLK = 1;
 124   2          } 
 125   1          return(ACC); 
 126   1      }
 127          /******************************************************************** 
 128          函 数 名：R1302()
 129          功    能：读取DS1302某地址的数据
 130          说    明：先写地址，后读命令/数据 (内部函数)
 131          调    用：RTInputByte() , RTOutputByte()
 132          入口参数：ucAddr: DS1302地址
 133          返 回 值：ucData :读取的数据
 134          ***********************************************************************/
 135          uchar R1302(uchar ucAddr)
 136          {
 137   1          uchar ucData;
 138   1          RST = 0;
 139   1          CLK = 0;
 140   1          RST = 1;
 141   1          RTInputByte(ucAddr);             /* 地址，命令 */
 142   1          CLK = 1;
 143   1          ucData = RTOutputByte();         /* 读1Byte数据 */
 144   1          RST = 0;
 145   1          return(ucData);
 146   1      }
 147          /******************************************************************** 
 148          函 数 名：W1302()
 149          功    能：往DS1302写入数据
 150          说    明：先写地址，后写命令/数据 (内部函数)
 151          调    用：RTInputByte() , RTOutputByte()
 152          入口参数：ucAddr: DS1302地址, ucData: 要写的数据
 153          返 回 值：无
 154          ***********************************************************************/
 155          void W1302(uchar ucAddr, uchar ucDa)
 156          {
 157   1          RST = 0;
 158   1          CLK = 0;
 159   1          RST = 1;
 160   1          RTInputByte(ucAddr);       /* 地址，命令 */
 161   1          RTInputByte(ucDa);       /* 写1Byte数据*/
 162   1          CLK = 1;
 163   1          RST = 0;
 164   1      }
 165          /******************读取DS1302中的时间****************/
 166          void du1302()
 167          {
 168   1          Sec=R1302(0x81);   //对取 秒 分 时 日 月 星期 年
 169   1          Cent=R1302(0x83);
 170   1          Hour=R1302(0x85);
 171   1          Day=R1302(0x87);
 172   1          Month=R1302(0x89);
 173   1          Week=R1302(0x8b);
 174   1          Year=R1302(0x8d);       
 175   1          //b=R1302(0xc1);
 176   1            //a=R1302(0xc3);
 177   1          //a=a/16*10+a%16;
 178   1         
C51 COMPILER V9.56.0.0   MAIN                                                              07/19/2019 10:58:36 PAGE 4   

 179   1      }
 180          /******************************************************************** 
 181          函 数 名：Set1302()
 182          功    能：设置初始时间
 183          说    明：先写地址，后读命令/数据(寄存器多字节方式)
 184          调    用：W1302()
 185          入口参数：pClock: 设置时钟数据地址 格式为: 秒 分 时 日 月 星期 年
 186                                         7Byte (BCD码)1B 1B 1B 1B 1B  1B  1B
 187          返 回 值：无
 188          ***********************************************************************/
 189          void Set1302(uchar *pClock) 
 190          {
 191   1          uchar h;
 192   1          uchar ucAddr = 0x80; 
 193   1          W1302(0x8e,0x00);           /* 控制命令,WP=0,写操作?*/
 194   1          for(h =7; h>0; h--)
 195   1          { 
 196   2              W1302(ucAddr,*pClock);  /* 秒 分 时 日 月 星期 年 */ 
 197   2              pClock++;
 198   2              ucAddr +=2;
 199   2          }
 200   1          //W1302(0xc0,0x01);
 201   1          //W1302(0XC2,0X03);
 202   1          W1302(0x8e,0x80);
 203   1      }
 204          
 205          sbit BELL=P1^1;
 206          sbit KEY=P1^0;
 207          unsigned char receiveData;
 208          
 209          void Delay()
 210          {
 211   1        unsigned char a,b,c;
 212   1        for(a=0;a<1;a++)
 213   1        for(b=0;b<1;b++)
 214   1        for(c=0;c<128;c++);
 215   1      }
 216          
 217          void Delay_text()
 218          {
 219   1        unsigned char a,b,c;
 220   1        for(a=0;a<2;a++)
 221   1        for(b=0;b<2;b++)
 222   1        for(c=0;c<128;c++);
 223   1      }
 224          
 225          void delay500ms(void)
 226          {
 227   1        unsigned char i,j,k;
 228   1        for(i=15;i>0;i--)
 229   1        for(j=202;j>0;j--)
 230   1        for(k=81;k>0;k--);
 231   1      }
 232          
 233          void init()  
 234          {  
 235   1          TMOD=0x20;              
 236   1          TH1=0xfd;      
 237   1          TL1=0xfd;  
 238   1          TR1=1;        
 239   1        
 240   1          SM0=0;  
C51 COMPILER V9.56.0.0   MAIN                                                              07/19/2019 10:58:36 PAGE 5   

 241   1          SM1=1;        
 242   1          REN=1;        
 243   1          EA=1;         
 244   1          ES=1;       
 245   1      }  
 246          
 247          void main()
 248          { 
 249   1        uint i;
 250   1        uint Cent_56=0;uint Cent_57=0;uint Cent_58=0;uint Cent_59=0;uint Cent_00=0;
 251   1        BELL=0;
 252   1        P2=0x00;
 253   1        P0=0x00;
 254   1        init();
 255   1        while(1)
 256   1        { 
 257   2          while(receiveData=='A')     /*显示文字*/
 258   2          {
 259   3            if(KEY==0) //红外接收管 判断起始位
 260   3              {         
 261   4                   for(i=0;i<96;i++) //每转一圈  移动一列  这里定义一圈中同时显示96/16=6个字，
 262   4                   {                                               
 263   5                      P0=text[2*i];
 264   5                      P2=change(text[2*i+1]);  //字幕数据高位送显示
 265   5                      Delay_text(); //延时让LED亮起来 每列延时的时间
 266   5                  }
 267   4              }
 268   3          }
 269   2          while(receiveData=='B')
 270   2          {     
 271   3            if(KEY==0) //红外接收管 判断起始位
 272   3              {   
 273   4                du1302();   
 274   4                  if((Cent==0x59)&&(Sec==0x56))
 275   4                  {                 
 276   5                      while(Cent_56==0)
 277   5                      {
 278   6                        BELL=1;
 279   6                        delay500ms();
 280   6                        BELL=0;
 281   6                        Cent_56=1;
 282   6                      }
 283   5                  }
 284   4                  if((Cent==0x59)&&(Sec==0x57))
 285   4                  {   
 286   5                      while(Cent_57==0)
 287   5                      {
 288   6                        BELL=1;
 289   6                        delay500ms();
 290   6                        BELL=0;
 291   6                        Cent_57=1;
 292   6                      }
 293   5                  }
 294   4                  if((Cent==0x59)&&(Sec==0x58))
 295   4                  {   
 296   5                      while(Cent_58==0)
 297   5                      {
 298   6                        BELL=1;
 299   6                        delay500ms();
 300   6                        BELL=0;
 301   6                        Cent_58=1;
 302   6                      }
C51 COMPILER V9.56.0.0   MAIN                                                              07/19/2019 10:58:36 PAGE 6   

 303   5                  }
 304   4                  if((Cent==0x59)&&(Sec==0x59))
 305   4                  {   
 306   5                      while(Cent_59==0)
 307   5                      {
 308   6                        BELL=1;
 309   6                        delay500ms();
 310   6                        BELL=0;
 311   6                        Cent_59=1;
 312   6                      }
 313   5                  }
 314   4                  if((Cent==0x00)&&(Sec==0x00))
 315   4                  {   
 316   5                      while(Cent_00==0)
 317   5                      {
 318   6                        BELL=1;
 319   6                        delay500ms();
 320   6                        BELL=0;
 321   6                        Cent_00=1;
 322   6                      }
 323   5                  }
 324   4                  if((Cent!=0x59)&&(Cent!=0x00))
 325   4                  {
 326   5                    Cent_56=Cent_57=Cent_58=Cent_59=Cent_00=0;
 327   5                  }
 328   4                  for(i=0;i<8;i++) 
 329   4                  { 
 330   5                      P0=clock[Hour/16][i*2]; //时的十位
 331   5                      P2=change(clock[Hour/16][i*2+1]);
 332   5                      Delay();
 333   5                  } 
 334   4                  for(i=0;i<8;i++) 
 335   4                  { 
 336   5                      P0=clock[Hour%16][i*2]; //时的个位
 337   5                      P2=change(clock[Hour%16][i*2+1]);  
 338   5                      Delay();    
 339   5                  }
 340   4                  for(i=0;i<8;i++) 
 341   4                  { 
 342   5                      P0=clock[10][i*2];      //显示两点
 343   5                      P2=change(clock[10][i*2+1]);
 344   5                      Delay();    
 345   5                  }
 346   4                  for(i=0;i<8;i++) 
 347   4                  { 
 348   5                      P0=clock[Cent/16][i*2];   //分的十位
 349   5                      P2=change(clock[Cent/16][i*2+1]); 
 350   5                      Delay();
 351   5                  }
 352   4                  for(i=0;i<8;i++) 
 353   4                  { 
 354   5                      P0=clock[Cent%16][i*2];   //分的个位
 355   5                      P2=change(clock[Cent%16][i*2+1]); 
 356   5                      Delay();
 357   5                  }
 358   4                  for(i=0;i<8;i++) 
 359   4                  { 
 360   5                      P0=clock[10][i*2];      //显示两点
 361   5                      P2=change(clock[10][i*2+1]);
 362   5                      Delay();    
 363   5                  }
 364   4                  for(i=0;i<8;i++) 
C51 COMPILER V9.56.0.0   MAIN                                                              07/19/2019 10:58:36 PAGE 7   

 365   4                  { 
 366   5                      P0=clock[Sec/16][i*2];     //秒的十位
 367   5                      P2=change(clock[Sec/16][i*2+1]);
 368   5                      Delay();
 369   5                  }
 370   4                  for(i=0;i<8;i++) 
 371   4                  { 
 372   5                      P0=clock[Sec%16][i*2];     //秒的个位
 373   5                      P2=change(clock[Sec%16][i*2+1]);
 374   5                      Delay();
 375   5                  }
 376   4                  Delay_text();
 377   4                  for(i=0;i<8;i++) 
 378   4                  { 
 379   5                      P0=clock[Day/16][i*2];         //日期 十位
 380   5                      P2=change(clock[Day/16][i*2+1]);
 381   5                      Delay();
 382   5                  }
 383   4                  for(i=0;i<8;i++) 
 384   4                  { 
 385   5                      P0=clock[Day%16][i*2];        //日期个位
 386   5                      P2=change(clock[Day%16][i*2+1]);
 387   5                      Delay();
 388   5                  }
 389   4                  for(i=0;i<8;i++) 
 390   4                  { 
 391   5                      P0=clock[11][i*2];          //-字符
 392   5                      P2=change(clock[11][i*2+1]);
 393   5                      Delay();
 394   5                  } 
 395   4                  for(i=0;i<8;i++) 
 396   4                  { 
 397   5                      P0=clock[Month/16][i*2];       //月的 十位
 398   5                      P2=change(clock[Month/16][i*2+1]);
 399   5                      Delay();
 400   5                  }
 401   4                  for(i=0;i<8;i++) 
 402   4                  { 
 403   5                      P0=clock[Month%16][i*2];       //月的个位
 404   5                      P2=change(clock[Month%16][i*2+1]);
 405   5                      Delay();
 406   5                  }
 407   4              P0=0xff;
 408   4              P2=0xff;
 409   4            } 
 410   3          }
 411   2          if(receiveData=='C')
 412   2          {
 413   3            Set1302(starts_time); 
 414   3          }
 415   2        }
 416   1      }
 417            void ser() interrupt 4  
 418          {    
 419   1        receiveData=SBUF;
 420   1        RI = 0;         
 421   1        SBUF=receiveData; 
 422   1        while(!TI);     
 423   1        TI=0;      
 424   1      }  


C51 COMPILER V9.56.0.0   MAIN                                                              07/19/2019 10:58:36 PAGE 8   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1296    ----
   CONSTANT SIZE    =    576    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     15      15
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
